================================================ 1 =====================================================================
Чесно кажучи не знайшов де ви "підкреслили, що вони мають бути “останнім засобом” для обміну даними в програмі."
Робив все зпочатку посвоєму, потім згідно ваших рекомендацій. В першому варіанті було безліч глобальних змінних.
в результаті маємо таке.
Змінні та об'єкти що перелічені нижче не хватило фантазії (скілів) передавати параметрами з методу в метод

   /* gameplay objects*/ три головні об'єкти геймплею, вся робота іде з ними
    private static GLabel scoreLbl;
    private static GOval ball;
    private static Paddle paddle;

    Змінні контролю стану, використовуюся в різних методах, тому - глобальні
    Можна було б їх запаковувати в кожному методі в масив і вертати його (можливо, але не зроблено)
    /* gameplay control variables*/
    private double directionX = 1;              // vx
    private double directionY = 3;              // vy
    private boolean isGamePaused = false;       // game pause control variable
    private int sticking = 0;                   // ball to paddle sticking control

    Для визначення руху вліво мишою для продовження виніс значення переривання нагору
    не дуже красиво, але так мені здалося зручніше та простіше
    private MouseEvent mEv = null;               // moved up to scope to detect left mouse movement


================================================ 2 =====================================================================
Не видумував ВОЛОСАПЕТ
bricksRemains = (NBRICKS_PER_ROW * NBRICK_ROWS)
...
 if (isBrickBoom()) bricksRemains--;
 if (bricksRemains <= 0)  //you win

Як варіант можна було б побудувати арайліст з цеглин і ремувати по одній поки його розмір не стане 0 (але це не точно).

Чи робили ви зміни в коді при тестуванні? Не зрозумів питання.
При тестуванні змінював константи.
При виявленні неправильної поведінки програми виправляв код.